!CHAPTER Features and Improvements

The following list shows in detail which features have been added or improved in
ArangoDB 2.6. ArangoDB 2.6 also contains several bugfixes that are not listed
here. For a list of bugfixes, please consult the [CHANGELOG](https://github.com/arangodb/arangodb/blob/devel/CHANGELOG).

!SECTION 

* added batch document removal and lookup commands:

  collection.lookupByKeys(keys)
collection.removeByKeys(keys)

  These commands can be used to perform multi-document lookup and removal operations efficiently
  from the ArangoShell. The argument to these operations is an array of document keys.

  Also added HTTP APIs for batch document commands:

  * PUT /\_api/simple/lookup-by-keys
  * PUT /\_api/simple/remove-by-keys


  * added dedicated collection export HTTP REST API

  ArangoDB now provides a dedicated collection export API, which can take snapshots of entire
  collections more efficiently than the general-purpose cursor API. The export API is useful
  to transfer the contents of an entire collection to a client application. It provides optional
  filtering on specific attributes.

  Tht export API is available at endpoint `POST /_api/export?collection=...`. The API has the
  same return value structure as the already established cursor API (`POST /_api/cursor`). 

  An introduction to the export API is given in this blog post:
  http://jsteemann.github.io/blog/2015/04/04/more-efficient-data-exports/

!SECTION AQL improvements

!SUBSECTION subquery optimizations for AQL queries

This optimization avoids copying intermediate results into subqueries that are not required
by the subquery.

A brief description can be found here:
http://jsteemann.github.io/blog/2015/05/04/subquery-optimizations/

!SUBSECTION Return value optimization for AQL queries

This optimization avoids copying the final query result inside the query's main `ReturnNode`.

A brief description can be found here:
http://jsteemann.github.io/blog/2015/05/04/return-value-optimization-for-aql/

!SUBSECTION Speed up AQL queries containing big `IN` lists for index lookups

`IN` lists used for index lookups had performance issues in previous versions of ArangoDB.
These issues have been addressed in 2.6 so using bigger `IN` lists for filtering is much
faster.

A brief description can be found here:
http://jsteemann.github.io/blog/2015/05/07/in-list-improvements/

!SUBSECTION Added alternative implementation for AQL COLLECT

The alternative method uses a hash table for grouping and does not require its input elements
to be sorted. It will be taken into account by the optimizer for `COLLECT` statements that do
not use an `INTO` clause.

In case a `COLLECT` statement can use the hash table variant, the optimizer will create an extra
plan for it at the beginning of the planning phase. In this plan, no extra `SORT` node will be
added in front of the `COLLECT` because the hash table variant of `COLLECT` does not require
sorted input. Instead, a `SORT` node will be added after it to sort its output. This `SORT` node
may be optimized away again in later stages. If the sort order of the result is irrelevant to
the user, adding an extra `SORT null` after a hash `COLLECT` operation will allow the optimizer to
remove the sorts altogether.

In addition to the hash table variant of `COLLECT`, the optimizer will modify the original plan
to use the regular `COLLECT` implementation. As this implementation requires sorted input, the
optimizer will insert a `SORT` node in front of the `COLLECT`. This `SORT` node may be optimized
away in later stages.

The created plans will then be shipped through the regular optimization pipeline. In the end,
the optimizer will pick the plan with the lowest estimated total cost as usual. The hash table
variant does not require an up-front sort of the input, and will thus be preferred over the
regular `COLLECT` if the optimizer estimates many input elements for the `COLLECT` node and 
cannot use an index to sort them.

The optimizer can be explicitly told to use the regular *sorted* variant of `COLLECT` by
suffixing a `COLLECT` statement with `OPTIONS { "method" : "sorted" }`. This will override the
optimizer guesswork and only produce the *sorted* variant of `COLLECT`.

A blog post on the new `COLLECT` implementation can be found here:
http://jsteemann.github.io/blog/2015/04/22/collecting-with-a-hash-table/

!SUBSECTION simplified return value syntax for data-modification AQL queries

ArangoDB 2.4 since version allows to return results from data-modification AQL queries. The
syntax for this was quite limited and verbose:

```
FOR i IN 1..10
  INSERT { value: i } IN test
  LET inserted = NEW
  RETURN inserted
```
The `LET inserted = NEW RETURN inserted` was required literally to return the inserted
documents. No calculations could be made using the inserted documents.

This is now more flexible. After a data-modification clause (e.g. `INSERT`, `UPDATE`, `REPLACE`,
`REMOVE`, `UPSERT`) there can follow any number of `LET` calculations. These calculations can
refer to the pseudo-values `OLD` and `NEW` that are created by the data-modification statements.

This allows returning projections of inserted or updated documents, e.g.:

```
FOR i IN 1..10
  INSERT { value: i } IN test
  RETURN { _key: NEW._key, value: i }
```

Still not every construct is allowed after a data-modification clause. For example, no functions
can be called that may access documents.

More information can be found here:
http://jsteemann.github.io/blog/2015/03/27/improvements-for-data-modification-queries/

!SUBSECTION added AQL `UPSERT` statement

This adds an `UPSERT` statement to AQL that is a combination of both `INSERT` and `UPDATE` /
`REPLACE`. The `UPSERT` will search for a matching document using a user-provided example.
If no document matches the example, the *insert* part of the `UPSERT` statement will be
executed. If there is a match, the *update* / *replace* part will be carried out:

```
UPSERT { page: 'index.html' }                 /* search example */
INSERT { page: 'index.html', pageViews: 1 } /* insert part */
UPDATE { pageViews: OLD.pageViews + 1 }     /* update part */
IN pageViews
```

`UPSERT` can be used with an `UPDATE` or `REPLACE` clause. The `UPDATE` clause will perform
a partial update of the found document, whereas the `REPLACE` clause will replace the found
document entirely. The `UPDATE` or `REPLACE` parts can refer to the pseudo-value `OLD`, which
contains all attributes of the found document.

`UPSERT` statements can optionally return values. In the following query, the return
attribute `found` will return the found document before the `UPDATE` was applied. If no
document was found, `found` will contain a value of `null`. The `updated` result attribute will
contain the inserted / updated document:

```
UPSERT { page: 'index.html' }                 /* search example */
INSERT { page: 'index.html', pageViews: 1 } /* insert part */
UPDATE { pageViews: OLD.pageViews + 1 }     /* update part */
IN pageViews
RETURN { found: OLD, updated: NEW }
```

A more detailed description of `UPSERT` can be found here:
http://jsteemann.github.io/blog/2015/03/27/preview-of-the-upsert-command/

!SECTION Web Interface

There have been some minor changes in the web interface:

- The query execution time is displayed in the AQL editor now
- The AQL query button **submit** is now renamed to **execute**
- We've added a query explain feature in the AQL editor
- We've added a demo page. This only is shown if demo data is available otherwise it is hidden
- ArangoDB's built-in web interface now uses sessions. Session information ids are stored in cookies, so clients using the web interface must accept cookies in order to use it
